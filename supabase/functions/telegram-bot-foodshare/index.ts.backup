/**
 * Telegram Bot FoodShare - Enhanced Version v3.0
 *
 * Features:
 * - Food sharing commands (/share, /find, /nearby)
 * - User profiles and preferences
 * - Location-based search
 * - Interactive inline keyboards
 * - Photo support for food items
 * - Impact tracking (food saved, CO2 reduced)
 * - Gamification (badges, points, challenges)
 * - Real-time notifications
 * - Zero external dependencies
 *
 * Performance:
 * - Lightweight bundle
 * - Fast cold starts
 * - Connection pooling
 * - In-memory caching
 */

import { createClient, SupabaseClient } from "jsr:@supabase/supabase-js@^2.47.10";
import { t, getUserLanguage } from "./lib/i18n.ts";
import * as emoji from "./lib/emojis.ts";
import * as msg from "./lib/messages.ts";

// ============================================================================
// Configuration & Types
// ============================================================================

const BOT_TOKEN = Deno.env.get("BOT_TOKEN");
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
const APP_URL = Deno.env.get("APP_URL") || "https://foodshare.club";

// User state management using database (persistent across function invocations)
async function getUserState(
  userId: number
): Promise<{ action: string; data: any; step?: string } | null> {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("telegram_user_states")
    .select("state")
    .eq("user_id", userId)
    .single();

  if (error || !data) return null;
  return data.state;
}

async function setUserState(
  userId: number,
  state: { action: string; data: any; step?: string } | null
): Promise<void> {
  const supabase = getSupabaseClient();

  if (state === null) {
    await supabase.from("telegram_user_states").delete().eq("user_id", userId);
  } else {
    await supabase.from("telegram_user_states").upsert({
      user_id: userId,
      state: state,
      updated_at: new Date().toISOString(),
    });
  }
}

interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
  callback_query?: TelegramCallbackQuery;
}

interface TelegramCallbackQuery {
  id: string;
  from: TelegramUser;
  message: TelegramMessage;
  data: string;
}

interface TelegramMessage {
  message_id: number;
  from?: TelegramUser;
  chat: TelegramChat;
  date: number;
  text?: string;
  photo?: any[];
  video?: any;
  location?: { latitude: number; longitude: number };
  caption?: string;
  reply_to_message?: TelegramMessage;
}

interface TelegramUser {
  id: number;
  is_bot: boolean;
  first_name: string;
  last_name?: string;
  username?: string;
}

interface TelegramChat {
  id: number;
  type: string;
}

interface UserStats {
  user_id: number;
  username: string | null;
  first_name: string | null;
  last_name: string | null;
  message_count: number;
  first_message_date: string;
  last_message_date: string;
  total_characters: number;
  media_count: number;
  reply_count: number;
  active_days: string[];
  emoji_usage: Record<string, number>;
  most_used_words: Record<string, number>;
}

// ============================================================================
// Connection Pooling
// ============================================================================

let supabaseClient: SupabaseClient | null = null;

function getSupabaseClient(): SupabaseClient {
  if (!supabaseClient) {
    const url = Deno.env.get("SUPABASE_URL");
    const key = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!url || !key) {
      throw new Error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
    }

    supabaseClient = createClient(url, key, {
      auth: { persistSession: false },
      db: { schema: "public" },
    });
  }

  return supabaseClient;
}

// ============================================================================
// In-Memory Cache
// ============================================================================

interface CacheEntry<T> {
  data: T;
  expires: number;
}

const cache = new Map<string, CacheEntry<any>>();

function getCached<T>(key: string): T | null {
  const entry = cache.get(key);

  if (!entry) return null;

  if (entry.expires < Date.now()) {
    cache.delete(key);
    return null;
  }

  return entry.data as T;
}

function setCache<T>(key: string, data: T, ttlMs: number = 300000): void {
  cache.set(key, {
    data,
    expires: Date.now() + ttlMs,
  });
}

// ============================================================================
// Profile Types
// ============================================================================

interface Profile {
  id: string;
  telegram_id: number | null;
  email: string | null;
  email_verified: boolean;
  first_name: string | null;
  nickname: string | null;
  location: string | null; // PostGIS geography point
  verification_code: string | null;
  verification_code_expires_at: string | null;
}

// ============================================================================
// Profile Management - Core Functions
// ============================================================================

/**
 * Get profile by telegram_id (returns null if not found)
 */
async function getProfileByTelegramId(telegramId: number): Promise<Profile | null> {
  const supabase = getSupabaseClient();

  const { data } = await supabase
    .from("profiles")
    .select("*")
    .eq("telegram_id", telegramId)
    .single();

  return data as Profile | null;
}

/**
 * Get profile by email (returns null if not found)
 */
async function getProfileByEmail(email: string): Promise<Profile | null> {
  const supabase = getSupabaseClient();

  const { data } = await supabase
    .from("profiles")
    .select("*")
    .eq("email", email)
    .single();

  return data as Profile | null;
}

/**
 * Check if user can perform actions that require email verification
 */
function requiresEmailVerification(profile: Profile): boolean {
  return !profile.email_verified;
}

/**
 * Generate a 6-digit verification code
 */
function generateVerificationCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Send verification email via edge function
 */
async function sendVerificationEmail(email: string, code: string): Promise<boolean> {
  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    const response = await fetch(`${supabaseUrl}/functions/v1/resend`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${supabaseKey}`,
      },
      body: JSON.stringify({
        to: email,
        subject: "FoodShare - Verify Your Email",
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #22c55e;">üçé FoodShare Email Verification</h2>
            <p>Your verification code is:</p>
            <div style="background: #f3f4f6; padding: 20px; text-align: center; border-radius: 8px; margin: 20px 0;">
              <span style="font-size: 32px; font-weight: bold; letter-spacing: 8px; color: #22c55e;">${code}</span>
            </div>
            <p>Enter this code in Telegram to verify your email.</p>
            <p style="color: #6b7280; font-size: 14px;">This code expires in 15 minutes.</p>
            <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;">
            <p style="color: #9ca3af; font-size: 12px;">If you didn't request this, please ignore this email.</p>
          </div>
        `,
      }),
    });

    return response.ok;
  } catch (error) {
    console.error("Failed to send verification email:", error);
    return false;
  }
}

/**
 * Handle email input from user - Improved authentication flow
 */
async function handleEmailInput(
  email: string,
  telegramUser: TelegramUser,
  chatId: number,
  lang: string = "en"
): Promise<void> {
  const supabase = getSupabaseClient();

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    await sendMessage(
      chatId,
      msg.errorMessage(
        t(lang, "auth.invalidEmailTitle"),
        t(lang, "auth.invalidEmailMessage") + "\n\n" +
        `${emoji.INFO} <b>${t(lang, "common.example")}:</b> <code>user@example.com</code>`
      )
    );
    return;
  }

  // Check if email already exists in database
  const existingProfile = await getProfileByEmail(email);

  // Case 1: Email exists with verified account - Sign In Flow
  if (existingProfile && existingProfile.email_verified) {
    // Check if already linked to another Telegram account
    if (existingProfile.telegram_id && existingProfile.telegram_id !== telegramUser.id) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          t(lang, "auth.emailAlreadyLinkedTitle"),
          t(lang, "auth.emailAlreadyLinkedMessage")
        )
      );
      return;
    }

    // Generate verification code for sign in
    const code = generateVerificationCode();
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

    await supabase
      .from("profiles")
      .update({
        verification_code: code,
        verification_code_expires_at: expiresAt.toISOString(),
      })
      .eq("id", existingProfile.id);

    const emailSent = await sendVerificationEmail(email, code);

    if (emailSent) {
      await sendMessage(
        chatId,
        msg.boxedHeader(`${emoji.KEY} ${t(lang, "auth.signInTitle")}`) +
        "\n\n" +
        `${emoji.SUCCESS} <b>${t(lang, "auth.accountFound")}</b>\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        t(lang, "auth.signInMessage") + "\n\n" +
        `${emoji.EMAIL} <b>${t(lang, "common.email")}:</b> <code>${email}</code>\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.EMAIL} <b>${t(lang, "auth.checkInbox")}</b>\n\n` +
        t(lang, "auth.codeEmailSent") + "\n\n" +
        `${emoji.KEY} ${t(lang, "auth.enterCodeToSignIn")}\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.SPARKLES} <i>${t(lang, "auth.afterSignIn")}:</i>\n\n` +
        msg.bulletList([
          { emoji: emoji.FOOD, text: t(lang, "auth.accessPosts") },
          { emoji: emoji.CHAT, text: t(lang, "auth.manageMessages") },
          { emoji: emoji.STATS, text: t(lang, "auth.trackImpact") },
        ]) +
        "\n\n" +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.CLOCK} ${t(lang, "auth.codeExpires")}\n` +
        `${emoji.REFRESH} ${t(lang, "auth.resendHint")}`
      );

      await setUserState(telegramUser.id, {
        action: "awaiting_verification_link",
        data: {
          existing_profile_id: existingProfile.id,
          email: email,
        },
      });
      return;
    } else {
      await sendMessage(
        chatId,
        msg.errorMessage(
          t(lang, "auth.emailDeliveryFailedTitle"),
          t(lang, "auth.emailDeliveryFailedMessage")
        )
      );
      return;
    }
  }

  // Case 2: Email exists but not verified - Complete Registration Flow
  if (existingProfile && !existingProfile.email_verified) {
    // Check if already linked to another Telegram account
    if (existingProfile.telegram_id && existingProfile.telegram_id !== telegramUser.id) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          t(lang, "auth.emailAlreadyLinkedTitle"),
          t(lang, "auth.emailAlreadyLinkedMessage")
        )
      );
      return;
    }

    // Update telegram_id if not set
    if (!existingProfile.telegram_id) {
      await supabase
        .from("profiles")
        .update({
          telegram_id: telegramUser.id,
          first_name: telegramUser.first_name,
          nickname: telegramUser.username || existingProfile.nickname,
        })
        .eq("id", existingProfile.id);
    }

    // Generate verification code to complete registration
    const code = generateVerificationCode();
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

    await supabase
      .from("profiles")
      .update({
        verification_code: code,
        verification_code_expires_at: expiresAt.toISOString(),
      })
      .eq("id", existingProfile.id);

    const emailSent = await sendVerificationEmail(email, code);

    if (emailSent) {
      await sendMessage(
        chatId,
        msg.boxedHeader(`${emoji.EMAIL} ${t(lang, "auth.completeRegistrationTitle")}`) +
        "\n\n" +
        `${emoji.SUCCESS} <b>${t(lang, "auth.accountFound")}</b>\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        t(lang, "auth.completeRegistrationMessage") + "\n\n" +
        `${emoji.EMAIL} <b>${t(lang, "common.email")}:</b> <code>${email}</code>\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.EMAIL} <b>${t(lang, "auth.checkInbox")}</b>\n\n` +
        t(lang, "auth.codeEmailSentComplete") + "\n\n" +
        `${emoji.KEY} ${t(lang, "auth.enterCodeToVerify")}\n\n` +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.SPARKLES} <i>${t(lang, "auth.afterVerification")}:</i>\n\n` +
        msg.bulletList([
          { emoji: emoji.FOOD, text: t(lang, "auth.shareFood") },
          { emoji: emoji.SEARCH, text: t(lang, "auth.findFood") },
          { emoji: emoji.STATS, text: t(lang, "auth.trackImpact") },
        ]) +
        "\n\n" +
        msg.divider("‚îÄ", 30) +
        "\n\n" +
        `${emoji.CLOCK} ${t(lang, "auth.codeExpires")}\n` +
        `${emoji.REFRESH} ${t(lang, "auth.resendHint")}`
      );

      await setUserState(telegramUser.id, {
        action: "awaiting_verification_link",
        data: {
          existing_profile_id: existingProfile.id,
          email: email,
        },
      });
      return;
    } else {
      await sendMessage(
        chatId,
        msg.errorMessage(
          t(lang, "auth.emailDeliveryFailedTitle"),
          t(lang, "auth.emailDeliveryFailedMessage")
        )
      );
      return;
    }
  }

  // Case 3: New email - Create New Profile
  const code = generateVerificationCode();
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000);
  const profileId = crypto.randomUUID();

  const { data: newProfile, error } = await supabase
    .from("profiles")
    .insert({
      id: profileId,
      telegram_id: telegramUser.id,
      first_name: telegramUser.first_name,
      nickname: telegramUser.username || null,
      email: email,
      email_verified: false,
      verification_code: code,
      verification_code_expires_at: expiresAt.toISOString(),
    })
    .select()
    .single();

  if (error) {
    console.error("Failed to create profile:", error);
    await sendMessage(
      chatId,
      msg.errorMessage(
        t(lang, "auth.registrationFailedTitle"),
        t(lang, "auth.registrationFailedMessage")
      )
    );
    return;
  }

  const emailSent = await sendVerificationEmail(email, code);

  if (emailSent) {
    await sendMessage(
      chatId,
      msg.boxedHeader(`${emoji.EMAIL} ${t(lang, "auth.verifyEmailTitle")}`) +
      "\n\n" +
      `${emoji.SUCCESS} <b>${t(lang, "auth.accountCreated")}</b>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      t(lang, "auth.codeSentTo") + "\n\n" +
      `${emoji.EMAIL} <code>${email}</code>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.KEY} <b>${t(lang, "auth.enterCodeToVerify")}</b>\n\n` +
      `${emoji.INFO} <i>${t(lang, "common.example")}: 123456</i>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.CLOCK} ${t(lang, "auth.codeExpires")}\n` +
      `${emoji.REFRESH} ${t(lang, "auth.resendHint")}`
    );

    await setUserState(telegramUser.id, {
      action: "awaiting_verification",
      data: {
        profile_id: newProfile.id,
        email: email,
      },
    });
  } else {
    // Delete the profile if email failed
    await supabase.from("profiles").delete().eq("id", profileId);

    await sendMessage(
      chatId,
      msg.errorMessage(
        t(lang, "auth.emailDeliveryFailedTitle"),
        t(lang, "auth.emailDeliveryFailedMessage")
      )
    );
  }
}

/**
 * Handle verification code input
 */
async function handleVerificationCode(
  code: string,
  telegramUser: TelegramUser,
  chatId: number
): Promise<boolean> {
  const supabase = getSupabaseClient();
  const userState = await getUserState(telegramUser.id);

  // Validate code format (6 digits)
  if (!/^\d{6}$/.test(code)) {
    await sendMessage(
      chatId,
      msg.errorMessage(
        "Invalid Code Format",
        "Please enter a 6-digit code.\n\n" +
        `${emoji.INFO} <b>Example:</b> <code>123456</code>\n\n` +
        `${emoji.REFRESH} Type /resend to get a new code`
      )
    );
    return false;
  }

  // Case 1: Linking to existing profile (Sign In or Complete Registration)
  if (userState?.action === "awaiting_verification_link") {
    const { existing_profile_id, email } = userState.data;

    const { data: existingProfile } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", existing_profile_id)
      .single();

    if (!existingProfile) {
      await sendMessage(
        chatId,
        msg.errorMessage("Profile Not Found", "Please try signing in again with /start")
      );
      await setUserState(telegramUser.id, null);
      return false;
    }

    // Check if code matches and hasn't expired
    if (existingProfile.verification_code !== code) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          "Incorrect Code",
          "The code you entered doesn't match.\n\n" +
          `${emoji.INFO} Please check your email and try again.\n\n` +
          `${emoji.REFRESH} Type /resend to get a new code`
        )
      );
      return false;
    }

    if (
      !existingProfile.verification_code_expires_at ||
      new Date(existingProfile.verification_code_expires_at) < new Date()
    ) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          "Code Expired",
          "Your verification code has expired.\n\n" +
          `${emoji.REFRESH} Type /resend to get a new code`
        )
      );
      return false;
    }

    // Link the Telegram account to the existing profile
    await supabase
      .from("profiles")
      .update({
        telegram_id: telegramUser.id,
        first_name: telegramUser.first_name,
        nickname: telegramUser.username || existingProfile.nickname,
        email_verified: true,
        verification_code: null,
        verification_code_expires_at: null,
      })
      .eq("id", existing_profile_id);

    await sendMessage(
      chatId,
      msg.boxedHeader(`${emoji.CELEBRATE} Successfully Signed In!`) +
      "\n\n" +
      `${emoji.SUCCESS} <b>Your Telegram account is now linked!</b>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.EMAIL} <b>Email:</b> <code>${email}</code>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.SPARKLES} <b>What's preserved:</b>\n\n` +
      msg.bulletList([
        { emoji: emoji.FOOD, text: "All your food posts" },
        { emoji: emoji.CHAT, text: "All your messages" },
        { emoji: emoji.STATS, text: "Your impact statistics" },
        { emoji: emoji.TROPHY, text: "Your badges and achievements" },
      ]) +
      "\n\n" +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.ROCKET} <b>Ready to go!</b>\n\n` +
      `Use the menu below to get started:`
    );

    await setUserState(telegramUser.id, null);

    // Show main menu
    setTimeout(() => handleStartCommand(chatId, telegramUser.id, telegramUser), 1000);

    return true;
  }

  // Case 2: Normal email verification for new registration
  if (userState?.action === "awaiting_verification") {
    const { profile_id, email } = userState.data;

    const { data: profile } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", profile_id)
      .single();

    if (!profile) {
      await sendMessage(
        chatId,
        msg.errorMessage("Profile Not Found", "Please try registering again with /start")
      );
      await setUserState(telegramUser.id, null);
      return false;
    }

    if (profile.verification_code !== code) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          "Incorrect Code",
          "The code you entered doesn't match.\n\n" +
          `${emoji.INFO} Please check your email and try again.\n\n` +
          `${emoji.REFRESH} Type /resend to get a new code`
        )
      );
      return false;
    }

    if (
      !profile.verification_code_expires_at ||
      new Date(profile.verification_code_expires_at) < new Date()
    ) {
      await sendMessage(
        chatId,
        msg.errorMessage(
          "Code Expired",
          "Your verification code has expired.\n\n" +
          `${emoji.REFRESH} Type /resend to get a new code`
        )
      );
      return false;
    }

    // Verify email and clear verification code
    await supabase
      .from("profiles")
      .update({
        email_verified: true,
        verification_code: null,
        verification_code_expires_at: null,
      })
      .eq("id", profile_id);

    await sendMessage(
      chatId,
      msg.boxedHeader(`${emoji.CELEBRATE} Email Verified!`) +
      "\n\n" +
      `${emoji.SUCCESS} <b>Welcome to FoodShare!</b>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.EMAIL} <b>Verified:</b> <code>${email}</code>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.SPARKLES} <b>You can now:</b>\n\n` +
      msg.bulletList([
        { emoji: emoji.FOOD, text: "Share food with /share" },
        { emoji: emoji.SEARCH, text: "Find food with /find" },
        { emoji: emoji.NEARBY, text: "Browse nearby with /nearby" },
        { emoji: emoji.STATS, text: "Track impact with /impact" },
      ]) +
      "\n\n" +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.ROCKET} <b>Let's get started!</b>`
    );

    await setUserState(telegramUser.id, null);

    // Check if there was a pending action
    if (userState?.data?.next_action === "share_food") {
      setTimeout(() => handleShareViaChat(chatId, telegramUser.id, telegramUser), 1000);
    } else {
      setTimeout(() => handleStartCommand(chatId, telegramUser.id, telegramUser), 1000);
    }

    return true;
  }

  // No active verification state
  await sendMessage(
    chatId,
    msg.errorMessage(
      "No Active Verification",
      "You don't have an active verification process.\n\n" +
      `${emoji.INFO} Use /start to begin.`
    )
  );
  return false;
}

/**
 * Handle resend verification code
 */
async function handleResendCode(telegramUser: TelegramUser, chatId: number): Promise<void> {
  const supabase = getSupabaseClient();
  const userState = await getUserState(telegramUser.id);

  // Check if we're in a verification flow
  if (
    userState?.action !== "awaiting_verification" &&
    userState?.action !== "awaiting_verification_link"
  ) {
    await sendMessage(
      chatId,
      msg.infoMessage(
        "No Active Verification",
        "You don't have an active verification process.\n\n" +
        `${emoji.INFO} Use /start to begin.`
      )
    );
    return;
  }

  let email: string | null = null;
  let profileId: string | null = null;

  // Determine which profile to resend to
  if (userState.action === "awaiting_verification_link") {
    // Resending for sign in flow
    profileId = userState.data.existing_profile_id;
    email = userState.data.email;
  } else {
    // Resending for registration flow
    const profile = await getProfileByTelegramId(telegramUser.id);
    if (profile) {
      profileId = profile.id;
      email = profile.email || userState.data.email;
    } else {
      email = userState.data.email;
    }
  }

  if (!email || !profileId) {
    await sendMessage(
      chatId,
      msg.errorMessage(
        "Email Not Found",
        "Please send your email address first."
      )
    );
    await setUserState(telegramUser.id, {
      action: "awaiting_email",
      data: {},
    });
    return;
  }

  // Generate new code
  const code = generateVerificationCode();
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

  await supabase
    .from("profiles")
    .update({
      verification_code: code,
      verification_code_expires_at: expiresAt.toISOString(),
    })
    .eq("id", profileId);

  const emailSent = await sendVerificationEmail(email, code);

  if (emailSent) {
    await sendMessage(
      chatId,
      msg.successMessage(
        "Code Resent!",
        `A new 6-digit verification code has been sent to:\n\n` +
        `${emoji.EMAIL} <code>${email}</code>\n\n` +
        `${emoji.KEY} Please enter the code below.\n\n` +
        `${emoji.CLOCK} Code expires in 15 minutes.`
      )
    );
  } else {
    await sendMessage(
      chatId,
      msg.errorMessage(
        "Email Delivery Failed",
        "We couldn't send the verification email.\n\n" +
        `${emoji.INFO} Please try again in a moment.`
      )
    );
  }
}

// ============================================================================
// Telegram API Methods
// ============================================================================

async function sendMessage(chatId: number, text: string, options: any = {}): Promise<boolean> {
  try {
    const response = await fetch(`${TELEGRAM_API}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: chatId,
        text,
        parse_mode: options.parse_mode || "HTML",
        ...options,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("Telegram API error:", result);
    }

    return result.ok;
  } catch (error) {
    console.error("Send message error:", error);
    return false;
  }
}

async function sendPhoto(
  chatId: number,
  photo: string,
  caption?: string,
  options: any = {}
): Promise<boolean> {
  try {
    const response = await fetch(`${TELEGRAM_API}/sendPhoto`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: chatId,
        photo,
        caption,
        parse_mode: "HTML",
        ...options,
      }),
    });

    const result = await response.json();
    return result.ok;
  } catch (error) {
    console.error("Send photo error:", error);
    return false;
  }
}

/**
 * Extract latitude and longitude from PostGIS geography point
 */
async function extractCoordinates(location: string): Promise<{ latitude: number; longitude: number } | null> {
  try {
    const supabase = getSupabaseClient();
    const { data, error } = await supabase.rpc('extract_coordinates', { geog: location });
    
    if (error || !data) {
      console.error("Error extracting coordinates:", error);
      return null;
    }
    
    return {
      latitude: data.latitude,
      longitude: data.longitude
    };
  } catch (error) {
    console.error("Extract coordinates error:", error);
    return null;
  }
}

async function sendLocation(chatId: number, latitude: number, longitude: number): Promise<boolean> {
  try {
    const response = await fetch(`${TELEGRAM_API}/sendLocation`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: chatId,
        latitude,
        longitude,
      }),
    });

    const result = await response.json();
    return result.ok;
  } catch (error) {
    console.error("Send location error:", error);
    return false;
  }
}

async function setWebhook(url: string): Promise<boolean> {
  try {
    const response = await fetch(`${TELEGRAM_API}/setWebhook`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        url,
        allowed_updates: ["message", "callback_query"],
      }),
    });

    const result = await response.json();
    return result.ok;
  } catch (error) {
    console.error("Set webhook error:", error);
    return false;
  }
}

// ============================================================================
// Command Handlers
// ============================================================================

async function handleShareViaChat(chatId: number, userId: number, telegramUser: TelegramUser): Promise<void> {
  // Check email verification first
  const profile = await getProfileByTelegramId(telegramUser.id);

  if (!profile || requiresEmailVerification(profile)) {
    await sendMessage(
      chatId,
      msg.infoMessage(
        "Email Verification Required",
        "To share food, you need to verify your email first.\n\n" +
        `${emoji.EMAIL} <b>Send your email address</b> to get started.\n` +
        `<i>Example: user@example.com</i>`
      )
    );

    await setUserState(userId, {
      action: "awaiting_email",
      data: { next_action: "share_food" },
    });
    return;
  }

  const state = { action: "sharing_food", data: {}, step: "photo" };
  await setUserState(userId, state);

  const shareMsg =
    `${emoji.CAMERA} <b>Share Food - Step 1/3</b>\n\n` +
    msg.progressBar(1, 3, 12) +
    " 33%\n\n" +
    msg.divider("‚îÄ", 25) +
    "\n\n" +
    `${emoji.PHOTO} Send me a photo of the food you want to share\n\n` +
    `${emoji.LIGHT_BULB} <i>Tip: Good photos attract more interest!</i>\n\n` +
    msg.divider("‚îÄ", 25) +
    "\n\n" +
    `${emoji.INFO} Type /cancel to stop`;

  await sendMessage(chatId, shareMsg);
}

async function handleStartCommand(
  chatId: number,
  userId: number,
  telegramUser: TelegramUser,
  languageCode?: string
): Promise<void> {
  const lang = await getUserLanguage(userId, languageCode);

  // Check if profile with telegram_id already exists
  const profile = await getProfileByTelegramId(telegramUser.id);

  // Case 1: Existing verified user - welcome back!
  if (profile && profile.email_verified) {
    const keyboard = {
      inline_keyboard: [
        [
          { text: `${emoji.FOOD} Share Food`, callback_data: "action_share" },
          { text: `${emoji.SEARCH} Find Food`, callback_data: "action_find" },
        ],
        [
          { text: `${emoji.NEARBY} Nearby Food`, callback_data: "action_nearby" },
          { text: `${emoji.USER} My Profile`, callback_data: "action_profile" },
        ],
        [
          { text: `${emoji.STATS} My Impact`, callback_data: "action_stats" },
          { text: `${emoji.TROPHY} Leaderboard`, callback_data: "action_leaderboard" },
        ],
        [{ text: `${emoji.LINK} Open FoodShare`, url: APP_URL }],
      ],
    };

    const welcomeBackMsg =
      msg.boxedHeader(`${emoji.WAVE} Welcome Back!`) +
      "\n\n" +
      `Hi <b>${profile.first_name || profile.nickname}</b>! ${emoji.SPARKLES}\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.SUCCESS} <b>Your account is verified and ready!</b>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.ROCKET} <b>Quick Actions:</b>\n\n` +
      msg.bulletList([
        { emoji: emoji.FOOD, text: "<b>Share</b> - Post surplus food" },
        { emoji: emoji.SEARCH, text: "<b>Find</b> - Search for food" },
        { emoji: emoji.NEARBY, text: "<b>Nearby</b> - Browse local food" },
        { emoji: emoji.STATS, text: "<b>Impact</b> - View your stats" },
      ]) +
      "\n\n" +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.LIGHT_BULB} <i>Use the buttons below or type /help for all commands</i>`;

    await sendMessage(chatId, welcomeBackMsg, { reply_markup: keyboard });
    return;
  }

  // Case 2: Profile exists but not verified - ask to complete verification
  if (profile && !profile.email_verified && profile.email) {
    const welcomeMsg =
      msg.boxedHeader(`${emoji.WAVE} Welcome Back!`) +
      "\n\n" +
      `Hi <b>${profile.first_name || telegramUser.first_name}</b>! ${emoji.CELEBRATE}\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.INFO} <b>Your account needs verification</b>\n\n` +
      `${emoji.EMAIL} <b>Email:</b> <code>${profile.email}</code>\n\n` +
      msg.divider("‚îÄ", 30) +
      "\n\n" +
      `${emoji.KEY} Send your email again to receive a new verification code.`;

    await sendMessage(chatId, welcomeMsg);

    await setUserState(userId, {
      action: "awaiting_email",
      data: {},
    });
    return;
  }

  // Case 3: New user - ask for email (sign in or register)
  const keyboard = {
    inline_keyboard: [
      [
        { text: `üá¨üáß English`, callback_data: "lang_en" },
        { text: `üá∑üá∫ –†—É—Å—Å–∫–∏–π`, callback_data: "lang_ru" },
        { text: `üá©üá™ Deutsch`, callback_data: "lang_de" },
      ],
    ],
  };

  const welcomeMsg =
    msg.boxedHeader(`${emoji.WAVE} ${t(lang, "welcome.title")}`) +
    "\n\n" +
    `Hi <b>${telegramUser.first_name}</b>! ${emoji.CELEBRATE}\n\n` +
    msg.divider("‚îÄ", 30) +
    "\n\n" +
    `${emoji.EARTH} <b>${t(lang, "auth.joinRevolution")}</b>\n\n` +
    msg.bulletList([
      { emoji: emoji.FOOD, text: t(lang, "auth.shareFood") },
      { emoji: emoji.SEARCH, text: t(lang, "auth.findFood") },
      { emoji: emoji.RECYCLE, text: t(lang, "auth.reduceWaste") },
      { emoji: emoji.STATS, text: t(lang, "auth.trackImpact") },
    ]) +
    "\n\n" +
    msg.divider("‚îÄ", 30) +
    "\n\n" +
    `${emoji.KEY} <b>${t(lang, "auth.getStarted")}:</b>\n\n` +
    `${emoji.EMAIL} <b>${t(lang, "auth.newUser")}</b> ${t(lang, "auth.sendEmailToRegister")}\n` +
    `${emoji.INFO} <i>${t(lang, "common.example")}: user@example.com</i>\n\n` +
    `${emoji.KEY} <b>${t(lang, "auth.haveAccount")}</b> ${t(lang, "auth.sendEmailToSignIn")}\n\n` +
    msg.divider("‚îÄ", 30) +
    "\n\n" +
    `${emoji.GLOBE} <b>${t(lang, "auth.selectLanguage")}:</b>`;

  await sendMessage(chatId, welcomeMsg, { reply_markup: keyboard });

  await setUserState(userId, {
    action: "awaiting_email",
    data: {},
  });
}

async function handleStatsCommand(
  chatId: number,
  userId: number,
  languageCode?: string
): Promise<void> {
  const lang = await getUserLanguage(userId, languageCode);
  try {
    const supabase = getSupabaseClient();
    const { data, error } = await supabase
      .from("telegram_user_activity")
      .select("*")
      .eq("user_id", userId)
      .single();

    if (error || !data) {
      await sendMessage(chatId, t(lang, "stats.noStatsYet"));
      return;
    }

    const stats = `
üìä <b>Your Statistics</b>

üí¨ Messages: ${data.message_count}
üìÖ Active Days: ${data.active_days?.length || 0}
üìù Characters: ${data.total_characters}
üñºÔ∏è Media: ${data.media_count}
‚Ü©Ô∏è Replies: ${data.reply_count}

First seen: ${data.first_message_date}
Last active: ${data.last_message_date}
    `.trim();

    await sendMessage(chatId, stats);
  } catch (error) {
    console.error("Stats error:", error);
    await sendMessage(chatId, t(lang, "common.error", { message: "fetching statistics" }));
  }
}

async function handleLeaderboardCommand(chatId: number, languageCode?: string): Promise<void> {
  const lang = await getUserLanguage(0, languageCode);
  try {
    // Check cache first
    const cached = getCached<string>("leaderboard");
    if (cached) {
      await sendMessage(chatId, cached);
      return;
    }

    const supabase = getSupabaseClient();
    const { data, error } = await supabase
      .from("telegram_user_activity")
      .select("first_name, username, message_count")
      .order("message_count", { ascending: false })
      .limit(10);

    if (error || !data || data.length === 0) {
      await sendMessage(chatId, t(lang, "leaderboard.noData"));
      return;
    }

    let leaderboard = "üèÜ <b>Top Contributors</b>\n\n";
    data.forEach((user, index) => {
      const medal = index === 0 ? "ü•á" : index === 1 ? "ü•à" : index === 2 ? "ü•â" : `${index + 1}.`;
      const name = user.first_name || user.username || "Anonymous";
      leaderboard += `${medal} ${name}: ${user.message_count} messages\n`;
    });

    // Cache for 5 minutes
    setCache("leaderboard", leaderboard, 300000);

    await sendMessage(chatId, leaderboard);
  } catch (error) {
    console.error("Leaderboard error:", error);
    await sendMessage(chatId, t(lang, "common.error", { message: "fetching leaderboard" }));
  }
}

async function handleShareCommand(
  chatId: number,
  userId: number,
  telegramUser: TelegramUser,
  languageCode?: string
): Promise<void> {
  const lang = await getUserLanguage(userId, languageCode);

  // Get profile and check verification
  const profile = await getProfileByTelegramId(telegramUser.id);

  if (!profile || requiresEmailVerification(profile)) {
    await sendMessage(
      chatId,
      msg.infoMessage(
        "Email Verification Required",
        "To share food, you need to verify your email first.\n\n" +
        `${emoji.EMAIL} <b>Send your email address</b> to get started.\n` +
        `<i>Example: user@example.com</i>`
      )
    );

    await setUserState(userId, {
      action: "awaiting_email",
      data: { next_action: "share_food" },
    });
    return;
  }

  const webAppUrl = `${APP_URL}/telegram-webapp/share-food.html`;

  const keyboard = {
    inline_keyboard: [
      [
        {
          text: t(lang, "share.openFormButton"),
          web_app: { url: webAppUrl },
        },
      ],
      [{ text: t(lang, "share.useChatButton"), callback_data: "share_via_chat" }],
    ],
  };

  await sendMessage(
    chatId,
    t(lang, "share.title") +
    "\n\n" +
    t(lang, "share.chooseMethod") +
    "\n\n" +
    t(lang, "share.webFormRecommended") +
    "\n" +
    t(lang, "share.chatAlternative") +
    "\n\n" +
    t(lang, "share.webFormFaster"),
    { reply_markup: keyboard }
  );
}

async function handleFindCommand(
  chatId: number,
  args: string,
  languageCode?: string
): Promise<void> {
  const lang = await getUserLanguage(0, languageCode);
  const supabase = getSupabaseClient();
  const searchTerm = args || "";

  let query = supabase
    .from("posts")
    .select("id, post_name, post_description, post_address, location, images")
    .eq("post_type", "food")
    .eq("is_active", true)
    .order("created_at", { ascending: false })
    .limit(5);

  if (searchTerm) {
    query = query.ilike("post_name", `%${searchTerm}%`);
  }

  const { data: foods, error } = await query;

  if (error || !foods || foods.length === 0) {
    await sendMessage(
      chatId,
      searchTerm ? t(lang, "find.noMatch", { query: searchTerm }) : t(lang, "find.noFood")
    );
    return;
  }

  await sendMessage(chatId, `${emoji.SEARCH} <b>Found ${foods.length} food items:</b>\n`);

  for (const food of foods) {
    const foodMsg =
      msg.foodCard({
        name: food.post_name,
        description: food.post_description || undefined,
        address: food.post_address || undefined,
      }) + `\n${emoji.LINK} <a href="${APP_URL}/product/${food.id}">View Details</a>`;

    if (food.images?.[0]) {
      await sendPhoto(chatId, food.images[0], foodMsg);
    } else {
      await sendMessage(chatId, foodMsg);
    }

    // Extract coordinates from PostGIS geography point if available
    if (food.location) {
      const coords = await extractCoordinates(food.location);
      if (coords) {
        await sendLocation(chatId, coords.latitude, coords.longitude);
      }
    }
  }
}

async function handleNearbyCommand(chatId: number, userId: number): Promise<void> {
  const supabase = getSupabaseClient();

  // Get user's location from profile
  const { data: profile } = await supabase
    .from("profiles")
    .select("location, search_radius_km")
    .eq("telegram_id", userId)
    .single();

  if (!profile?.location) {
    await sendMessage(
      chatId,
      "üìç <b>Location Not Set</b>\n\n" +
      "Please set your location first using /profile\n" +
      "Or share your location now:",
      {
        reply_markup: {
          keyboard: [[{ text: "üìç Share Location", request_location: true }]],
          resize_keyboard: true,
          one_time_keyboard: true,
        },
      }
    );
    return;
  }

  const radius = profile.search_radius_km || 5;

  // Find nearby food using PostGIS - pass the geography point directly
  const { data: nearbyFoods, error } = await supabase.rpc("find_nearby_posts_geography", {
    user_location: profile.location,
    radius_km: radius,
    post_type: "food",
  });

  if (error || !nearbyFoods || nearbyFoods.length === 0) {
    await sendMessage(
      chatId,
      `üìç No food found within ${radius}km of your location.\n\n` +
      "Try increasing your search radius in /profile"
    );
    return;
  }

  await sendMessage(
    chatId,
    `üìç <b>Found ${nearbyFoods.length} food items within ${radius}km:</b>\n`
  );

  for (const food of nearbyFoods.slice(0, 5)) {
    const text = `
üçé <b>${food.post_name}</b>
üìç ${food.distance_km?.toFixed(1)}km away
üìù ${food.post_description?.substring(0, 100) || "No description"}

üîó <a href="${APP_URL}/product/${food.id}">View & Claim</a>
    `.trim();

    if (food.images?.[0]) {
      await sendPhoto(chatId, food.images[0], text);
    } else {
      await sendMessage(chatId, text);
    }
  }
}

async function handleProfileCommand(chatId: number, userId: number): Promise<void> {
  const supabase = getSupabaseClient();

  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("telegram_id", userId)
    .single();

  if (!profile) {
    await sendMessage(
      chatId,
      "üë§ <b>Profile Not Found</b>\n\n" +
      "Link your Telegram account on FoodShare:\n" +
      `üîó <a href="${APP_URL}/profile">Open Profile Settings</a>`
    );
    return;
  }

  const stats = await getUserImpactStats(userId);

  const profileCard = msg.card(
    `${emoji.USER} Your FoodShare Profile`,
    [
      `<b>${profile.first_name || profile.nickname || "User"}</b>`,
      `${emoji.LOCATION} ${profile.location ? "Location Set" : "No location"}`,
      `${emoji.COMPASS} Search Radius: ${profile.search_radius_km || 5}km`,
      "",
      `<b>${emoji.STATS} Your Impact:</b>`,
      `${emoji.FOOD} Food Shared: ${stats.foodsShared}`,
      `${emoji.RECYCLE} Waste Prevented: ${stats.kgSaved}kg`,
      `${emoji.EARTH} CO2 Saved: ${stats.co2Saved}kg`,
    ],
    `${emoji.LINK} Edit on Website`
  );

  const keyboard = {
    inline_keyboard: [
      [
        { text: `${emoji.LOCATION} Update Location`, callback_data: "profile_location" },
        { text: `${emoji.COMPASS} Set Radius`, callback_data: "profile_radius" },
      ],
      [{ text: `${emoji.LINK} Open Profile`, url: `${APP_URL}/profile/${profile.id}` }],
    ],
  };

  await sendMessage(chatId, profileCard, { reply_markup: keyboard });
}

async function handleImpactCommand(chatId: number, userId: number): Promise<void> {
  const stats = await getUserImpactStats(userId);

  const impactMsg =
    msg.boxedHeader(`${emoji.EARTH} Your Environmental Impact`) +
    "\n\n" +
    msg.impactStats({
      foodShared: stats.foodsShared,
      foodClaimed: stats.foodsClaimed,
      kgSaved: stats.kgSaved,
      co2Saved: stats.co2Saved,
    }) +
    "\n\n" +
    msg.divider("‚îÄ", 25) +
    "\n\n" +
    `${emoji.CALENDAR} <b>Member Since:</b> ${stats.memberSince}\n` +
    `${emoji.FIRE} <b>Active Days:</b> ${stats.activeDays}\n\n` +
    getBadges(stats) +
    "\n" +
    msg.divider("‚îÄ", 25) +
    "\n\n" +
    `${emoji.SPARKLES} <i>Keep up the great work! Every share makes a difference.</i>`;

  await sendMessage(chatId, impactMsg);
}

async function getUserImpactStats(userId: number): Promise<any> {
  const supabase = getSupabaseClient();

  const { data: profile } = await supabase
    .from("profiles")
    .select("id, created_time")
    .eq("telegram_id", userId)
    .single();

  if (!profile) {
    return {
      foodsShared: 0,
      foodsClaimed: 0,
      kgSaved: 0,
      co2Saved: 0,
      moneySaved: 0,
      memberSince: "Unknown",
      activeDays: 0,
    };
  }

  // Get shared food count
  const { count: sharedCount } = await supabase
    .from("posts")
    .select("*", { count: "exact", head: true })
    .eq("profile_id", profile.id)
    .eq("post_type", "food");

  // Get claimed food count (from messages/interactions)
  const { count: claimedCount } = await supabase
    .from("messages")
    .select("*", { count: "exact", head: true })
    .eq("sender_id", profile.id);

  // Estimate impact (average food item = 0.5kg, CO2 = 2.5kg per kg food)
  const kgSaved = (sharedCount || 0) * 0.5;
  const co2Saved = kgSaved * 2.5;
  const moneySaved = kgSaved * 5; // $5 per kg average

  // Get activity stats
  const { data: activity } = await supabase
    .from("telegram_user_activity")
    .select("active_days")
    .eq("user_id", userId)
    .single();

  return {
    foodsShared: sharedCount || 0,
    foodsClaimed: claimedCount || 0,
    kgSaved: Math.round(kgSaved * 10) / 10,
    co2Saved: Math.round(co2Saved * 10) / 10,
    moneySaved: Math.round(moneySaved),
    memberSince: new Date(profile.created_time).toLocaleDateString(),
    activeDays: activity?.active_days?.length || 0,
  };
}

function getBadges(stats: any): string {
  const badges = [];

  if (stats.foodsShared >= 50) badges.push("üèÜ Super Sharer");
  else if (stats.foodsShared >= 20) badges.push("‚≠ê Active Sharer");
  else if (stats.foodsShared >= 5) badges.push("üåü Sharer");

  if (stats.foodsClaimed >= 30) badges.push("üéØ Food Rescuer");
  else if (stats.foodsClaimed >= 10) badges.push("üé™ Active Claimer");

  if (stats.kgSaved >= 25) badges.push("‚ôªÔ∏è Eco Warrior");
  else if (stats.kgSaved >= 10) badges.push("üå± Green Hero");

  if (stats.activeDays >= 30) badges.push("üî• 30-Day Streak");
  else if (stats.activeDays >= 7) badges.push("üìÖ Weekly Active");

  return badges.length > 0 ? `\nüèÖ <b>Badges:</b> ${badges.join(" ‚Ä¢ ")}\n` : "";
}

/**
 * Handle language selection from callback
 */
async function handleLanguageSelection(chatId: number, userId: number, lang: string): Promise<void> {
  const supabase = getSupabaseClient();
  
  // Store language preference in user state
  await supabase
    .from("telegram_user_states")
    .upsert({
      user_id: userId,
      state: { language: lang },
      updated_at: new Date().toISOString(),
    });

  const messages = {
    en: "‚úÖ Language set to English!",
    ru: "‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ –†—É—Å—Å–∫–∏–π!",
    de: "‚úÖ Sprache auf Deutsch eingestellt!",
  };

  await sendMessage(chatId, messages[lang as keyof typeof messages] || messages.en);
}

/**
 * Handle language command
 */
async function handleLanguageCommand(chatId: number, userId: number): Promise<void> {
  const lang = await getUserLanguage(userId);
  
  const keyboard = {
    inline_keyboard: [
      [
        { text: `üá¨üáß English`, callback_data: "lang_en" },
        { text: `üá∑üá∫ –†—É—Å—Å–∫–∏–π`, callback_data: "lang_ru" },
        { text: `üá©üá™ Deutsch`, callback_data: "lang_de" },
      ],
    ],
  };

  await sendMessage(
    chatId,
    msg.boxedHeader(`${emoji.GLOBE} ${t(lang, "language.selectTitle")}`) +
    "\n\n" +
    t(lang, "language.selectMessage"),
    { reply_markup: keyboard }
  );
}

async function handleHelpCommand(chatId: number): Promise<void> {
  const keyboard = {
    inline_keyboard: [
      [
        { text: `${emoji.FOOD} Share Food`, callback_data: "action_share" },
        { text: `${emoji.SEARCH} Find Food`, callback_data: "action_find" },
      ],
      [{ text: `${emoji.LINK} Open FoodShare`, url: APP_URL }],
    ],
  };

  const helpMsg =
    msg.boxedHeader(`${emoji.PLATE} FoodShare Bot Help`) +
    "\n\n" +
    `${emoji.FOOD} <b>Food Sharing:</b>\n` +
    msg.bulletList([
      { emoji: emoji.SHARE, text: "/share - Share surplus food" },
      { emoji: emoji.SEARCH, text: "/find [item] - Search for food" },
      { emoji: emoji.NEARBY, text: "/nearby - Food near your location" },
    ]) +
    "\n\n" +
    `${emoji.USER} <b>Profile:</b>\n` +
    msg.bulletList([
      { emoji: emoji.USER, text: "/profile - View/edit your profile" },
      { emoji: emoji.EARTH, text: "/impact - Your environmental impact" },
    ]) +
    "\n\n" +
    `${emoji.STATS} <b>Community:</b>\n` +
    msg.bulletList([
      { emoji: emoji.CHART, text: "/stats - Your activity statistics" },
      { emoji: emoji.TROPHY, text: "/leaderboard - Top contributors" },
    ]) +
    "\n\n" +
    `${emoji.INFO} <b>Other:</b>\n` +
    msg.bulletList([
      { emoji: emoji.GLOBE, text: "/language - Change language" },
      { emoji: emoji.INFO, text: "/help - Show this message" },
      { emoji: emoji.ERROR, text: "/cancel - Cancel current action" },
    ]) +
    "\n\n" +
    msg.divider("‚îÄ", 25) +
    "\n\n" +
    `${emoji.LIGHT_BULB} <i>Use the buttons below for quick actions!</i>`;

  await sendMessage(chatId, helpMsg, { reply_markup: keyboard });
}

// ============================================================================
// Message Tracking
// ============================================================================

async function trackMessage(message: TelegramMessage): Promise<void> {
  const userId = message.from?.id;

  if (!userId) return;

  const dateStr = new Date(message.date * 1000).toISOString().split("T")[0];

  // Build stats update
  const stats = {
    user_id: userId,
    username: message.from?.username || null,
    first_name: message.from?.first_name || null,
    last_name: message.from?.last_name || null,
    last_message_date: dateStr,
  };

  // Count message
  const textLength = message.text?.length || 0;

  // Extract emojis
  const emojiRegex = /[\p{Emoji_Presentation}\p{Emoji}]/gu;
  const emojis = message.text?.match(emojiRegex) || [];
  const emojiUsage: Record<string, number> = {};
  emojis.forEach((emoji) => {
    emojiUsage[emoji] = (emojiUsage[emoji] || 0) + 1;
  });

  // Extract words
  const words = message.text?.toLowerCase().split(/\s+/) || [];
  const wordUsage: Record<string, number> = {};
  words.forEach((word) => {
    if (word.length > 3) {
      wordUsage[word] = (wordUsage[word] || 0) + 1;
    }
  });

  // Track activity (optional - disabled if function doesn't exist)
  try {
    const supabase = getSupabaseClient();

    const { error } = await supabase.rpc("record_activity", {
      p_user_id: userId,
      p_username: stats.username,
      p_first_name: stats.first_name,
      p_last_name: stats.last_name,
      p_date: dateStr,
      p_message_count: 1,
      p_characters: textLength,
      p_media_count: message.photo || message.video ? 1 : 0,
      p_reply_count: message.reply_to_message ? 1 : 0,
      p_emoji_usage: emojiUsage,
      p_word_usage: wordUsage,
    });

    if (error) {
      // Silently fail - activity tracking is optional
      console.log("Activity tracking unavailable:", error.message);
    }
  } catch (e) {
    // Silently fail - activity tracking is optional
    console.log("Activity tracking error:", e);
  }
}

// ============================================================================
// Geocoding Helper
// ============================================================================

async function geocodeLocation(
  address: string
): Promise<{ latitude: number; longitude: number } | null> {
  try {
    // Use Nominatim (OpenStreetMap) for free geocoding
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;

    const response = await fetch(url, {
      headers: {
        "User-Agent": "FoodShare-Bot/1.0",
      },
    });

    const data = await response.json();

    if (data && data.length > 0) {
      return {
        latitude: parseFloat(data[0].lat),
        longitude: parseFloat(data[0].lon),
      };
    }

    return null;
  } catch (error) {
    console.error("Geocoding error:", error);
    return null;
  }
}

// ============================================================================
// Callback Query Handler (for inline buttons)
// ============================================================================

async function handleCallbackQuery(callbackQuery: any): Promise<void> {
  const chatId = callbackQuery.message.chat.id;
  const userId = callbackQuery.from.id;
  const data = callbackQuery.data;

  // Answer callback query to remove loading state
  await fetch(`${TELEGRAM_API}/answerCallbackQuery`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ callback_query_id: callbackQuery.id }),
  });

  switch (data) {
    case "action_share":
      await handleShareCommand(chatId, userId, callbackQuery.from, callbackQuery.from?.language_code);
      break;
    case "share_via_chat":
      await handleShareViaChat(chatId, userId, callbackQuery.from);
      break;
    case "action_find":
      await handleFindCommand(chatId, "", callbackQuery.from?.language_code);
      break;
    case "action_nearby":
      await handleNearbyCommand(chatId, userId);
      break;
    case "action_profile":
      await handleProfileCommand(chatId, userId);
      break;
    case "profile_location":
      // Check verification before allowing profile updates
      const profileLoc = await getProfileByTelegramId(callbackQuery.from.id);
      if (!profileLoc || requiresEmailVerification(profileLoc)) {
        await sendMessage(chatId, msg.infoMessage("Verification Required", "Please verify your email to update your profile."));
        return;
      }
      await sendMessage(chatId, `${emoji.LOCATION} <b>Send your new location</b>\n\nUse the attachment menu to send your current location.`);
      await setUserState(userId, { action: "updating_profile_location", data: {} });
      break;
    case "profile_radius":
      // Check verification
      const profileRad = await getProfileByTelegramId(callbackQuery.from.id);
      if (!profileRad || requiresEmailVerification(profileRad)) {
        await sendMessage(chatId, msg.infoMessage("Verification Required", "Please verify your email to update your profile."));
        return;
      }
      await sendMessage(chatId, `${emoji.COMPASS} <b>Enter search radius (km)</b>\n\nType a number between 1 and 50.`);
      await setUserState(userId, { action: "setting_radius", data: {} });
      break;
    case "action_stats":
      await handleStatsCommand(chatId, userId, callbackQuery.from?.language_code);
      break;
    case "action_leaderboard":
      await handleLeaderboardCommand(chatId, callbackQuery.from?.language_code);
      break;
    case "lang_en":
    case "lang_ru":
    case "lang_de":
      await handleLanguageSelection(chatId, userId, data.replace("lang_", ""), callbackQuery.from);
      break;
    case "back_to_start":
      await handleStartCommand(chatId, userId, callbackQuery.from, callbackQuery.from?.language_code);
      break;
    default:
      // Unknown callback
      break;
  }
}

/**
 * Handle language selection
 */
async function handleLanguageSelection(
  chatId: number,
  userId: number,
  lang: string,
  telegramUser: TelegramUser
): Promise<void> {
  const supabase = getSupabaseClient();

  // Save language preference to user state
  await supabase
    .from("telegram_user_states")
    .upsert({
      user_id: userId,
      state: { language: lang },
      updated_at: new Date().toISOString(),
    });

  const langNames: Record<string, string> = {
    en: "English üá¨üáß",
    ru: "–†—É—Å—Å–∫–∏–π üá∑üá∫",
    de: "Deutsch üá©üá™",
  };

  await sendMessage(
    chatId,
    msg.successMessage(
      t(lang, "language.changed"),
      `${t(lang, "language.selectedLanguage")}: <b>${langNames[lang]}</b>\n\n${t(lang, "language.continueMessage")}`
    )
  );

  // Continue with the start flow
  setTimeout(() => handleStartCommand(chatId, userId, telegramUser, lang), 500);
}

// ============================================================================
// Multi-Step Conversation Handlers
// ============================================================================

async function handleLocationMessage(message: TelegramMessage): Promise<void> {
  const userId = message.from?.id;
  const chatId = message.chat.id;

  if (!userId || !message.location) return;

  const userState = await getUserState(userId);

  if (userState?.action === "sharing_food" && userState.step === "location") {
    userState.data.location = message.location;

    // Complete the sharing
    await completeSharing(chatId, userId, userState.data.description, userState.data, await getUserLanguage(userId));
    await setUserState(userId, null);
    return;
  }

  if (userState?.action === "updating_profile_location") {
    const supabase = getSupabaseClient();
    // Create PostGIS point from latitude/longitude
    const point = `POINT(${message.location.longitude} ${message.location.latitude})`;
    await supabase
      .from("profiles")
      .update({
        location: point,
      })
      .eq("telegram_id", userId);

    await sendMessage(chatId, msg.successMessage("Location Updated", "Your profile location has been updated successfully!"));
    await setUserState(userId, null);

    // Show updated profile
    await handleProfileCommand(chatId, userId);
    return;
  }
}

async function handlePhotoMessage(message: TelegramMessage): Promise<void> {
  const userId = message.from?.id;
  const chatId = message.chat.id;

  if (!userId || !message.photo) return;

  const userState = await getUserState(userId);

  if (userState?.action === "sharing_food") {
    // Get the largest photo
    const photo = message.photo[message.photo.length - 1];
    userState.data.photo = photo.file_id;
    userState.data.caption = message.caption || "";
    userState.step = "description";
    await setUserState(userId, userState);

    const descMsg =
      `${emoji.SUCCESS} <b>Photo Received!</b>\n\n` +
      `${emoji.TEXT} <b>Share Food - Step 2/3</b>\n\n` +
      msg.progressBar(2, 3, 12) +
      " 67%\n\n" +
      msg.divider("‚îÄ", 25) +
      "\n\n" +
      "Tell people about your food:\n" +
      msg.bulletList([
        { emoji: emoji.FOOD, text: "What is it?" },
        { emoji: emoji.INFO, text: "How much?" },
        { emoji: emoji.CLOCK, text: "When to pick up?" },
      ]) +
      "\n\n" +
      msg.divider("‚îÄ", 20) +
      "\n\n" +
      "<b>Example:</b>\n" +
      "<i>Fresh Apples from My Garden\n\n" +
      "About 2kg of organic apples.\n" +
      "Perfect for eating or baking.\n" +
      "Available for pickup today until 6pm.</i>\n\n" +
      msg.divider("‚îÄ", 25);

    await sendMessage(chatId, descMsg);
  }
}

async function handleTextMessage(message: TelegramMessage): Promise<void> {
  const userId = message.from?.id;
  const chatId = message.chat.id;
  const text = message.text?.trim();

  if (!userId || !text || !message.from) return;

  const lang = await getUserLanguage(userId, message.from?.language_code);
  const userState = await getUserState(userId);

  if (text === "/cancel" || text === "‚ùå Cancel") {
    await setUserState(userId, null);
    await sendMessage(chatId, t(lang, "common.cancel"), {
      reply_markup: { remove_keyboard: true },
    });
    return;
  }

  // Handle email input
  if (userState?.action === "awaiting_email") {
    await handleEmailInput(text, message.from, chatId);
    return;
  }

  // Handle verification code input (both normal and linking)
  if (
    userState?.action === "awaiting_verification" ||
    userState?.action === "awaiting_verification_link"
  ) {
    await handleVerificationCode(text, message.from, chatId);
    return;
  }

  if (userState?.action === "setting_radius") {
    const radius = parseFloat(text);
    if (isNaN(radius) || radius < 1 || radius > 50) {
      await sendMessage(chatId, msg.errorMessage("Invalid Radius", "Please enter a number between 1 and 50."));
      return;
    }

    const supabase = getSupabaseClient();
    await supabase
      .from("profiles")
      .update({ search_radius_km: radius })
      .eq("telegram_id", userId);

    await sendMessage(chatId, msg.successMessage("Radius Updated", `Search radius set to ${radius}km.`));
    await setUserState(userId, null);

    // Show updated profile
    await handleProfileCommand(chatId, userId);
    return;
  }

  if (userState?.action === "updating_profile_location") {
    // Geocode the text location
    await sendMessage(chatId, t(lang, "share.lookingUpLocation"));
    const coords = await geocodeLocation(text);

    if (coords) {
      const supabase = getSupabaseClient();
      // Create PostGIS point from latitude/longitude
      const point = `POINT(${coords.longitude} ${coords.latitude})`;
      await supabase
        .from("profiles")
        .update({
          location: point,
        })
        .eq("telegram_id", userId);

      await sendMessage(chatId, msg.successMessage("Location Updated", "Your profile location has been updated successfully!"));
      await setUserState(userId, null);

      // Show updated profile
      await handleProfileCommand(chatId, userId);
    } else {
      await sendMessage(chatId, t(lang, "share.locationNotFound"));
    }
    return;
  }

  if (userState?.action === "sharing_food") {
    if (userState.step === "description" && userState.data.photo) {
      // Save description and ask for location
      userState.data.description = text;
      userState.step = "location";
      await setUserState(userId, userState);

      await sendMessage(chatId, t(lang, "share.step3Location"));
      return;
    }

    if (userState.step === "location" && userState.data.photo && userState.data.description) {
      if (text.toLowerCase() === "skip") {
        // Use profile location
        await completeSharing(chatId, userId, userState.data.description, userState.data, lang);
        await setUserState(userId, null);
        return;
      }

      // Geocode the text location
      await sendMessage(chatId, t(lang, "share.lookingUpLocation"));
      const coords = await geocodeLocation(text);

      if (coords) {
        userState.data.location = coords;
        userState.data.locationText = text;
        await completeSharing(chatId, userId, userState.data.description, userState.data, lang);
        await setUserState(userId, null);
      } else {
        await sendMessage(chatId, t(lang, "share.locationNotFound"));
      }
      return;
    }
  }
}

/**
 * Upload Telegram photo to Supabase storage using post ID as filename
 */
async function uploadTelegramPhotoToStorage(
  fileId: string,
  postId: number
): Promise<string | null> {
  try {
    // Get file info from Telegram
    const fileInfoResponse = await fetch(`${TELEGRAM_API}/getFile?file_id=${fileId}`);
    const fileInfo = await fileInfoResponse.json();

    if (!fileInfo.ok) {
      console.error("Failed to get file info:", fileInfo);
      return null;
    }

    const filePath = fileInfo.result.file_path;
    const fileUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${filePath}`;

    // Download the file from Telegram
    const photoResponse = await fetch(fileUrl);
    if (!photoResponse.ok) {
      console.error("Failed to download photo from Telegram");
      return null;
    }

    const photoBlob = await photoResponse.blob();
    const photoBuffer = await photoBlob.arrayBuffer();

    // Use post ID as filename (matching your existing system)
    const extension = filePath.split(".").pop() || "jpg";
    const fileName = `${postId}.${extension}`;

    // Upload to Supabase storage (posts bucket)
    const supabase = getSupabaseClient();
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("posts")
      .upload(fileName, photoBuffer, {
        contentType: photoBlob.type || "image/jpeg",
        upsert: true, // Allow overwriting if post is updated
      });

    if (uploadError) {
      console.error("Failed to upload to Supabase storage:", uploadError);
      return null;
    }

    // Get public URL
    const { data: urlData } = supabase.storage.from("posts").getPublicUrl(fileName);

    return urlData.publicUrl;
  } catch (error) {
    console.error("Error in uploadTelegramPhotoToStorage:", error);
    return null;
  }
}

async function completeSharing(
  chatId: number,
  userId: number,
  description: string,
  data: any,
  lang: string
): Promise<void> {
  const supabase = getSupabaseClient();

  // Get user profile with location
  console.log("Looking up profile for telegram_id:", userId, "type:", typeof userId);
  
  // Try both as number and as string in case of type mismatch
  let profile = null;
  let profileError = null;
  
  const { data: profileData, error: err1 } = await supabase
    .from("profiles")
    .select("id, telegram_id, location, email")
    .eq("telegram_id", userId)
    .maybeSingle();
  
  if (profileData) {
    profile = profileData;
  } else {
    // Try as string
    const { data: profileData2, error: err2 } = await supabase
      .from("profiles")
      .select("id, telegram_id, location, email")
      .eq("telegram_id", userId.toString())
      .maybeSingle();
    
    profile = profileData2;
    profileError = err2;
  }

  console.log("Profile lookup result:", { profile, profileError, userId });

  if (profileError || !profile) {
    console.error("Profile lookup error:", profileError);
    await sendMessage(
      chatId,
      msg.errorMessage(
        "Profile Not Found",
        `We couldn't find your profile for Telegram ID: ${userId}\n\n` +
        `${emoji.INFO} Please try /start again to set up your account.`
      )
    );
    return;
  }

  // Determine location - use provided location or profile location
  let locationPoint = null;
  if (data.location?.latitude && data.location?.longitude) {
    // User provided location in this request
    locationPoint = `POINT(${data.location.longitude} ${data.location.latitude})`;
  } else if (profile.location) {
    // Use profile's saved location
    locationPoint = profile.location;
  }

  // Check if we have a valid location
  if (!locationPoint) {
    await sendMessage(
      chatId,
      msg.errorMessage(
        "Location Required",
        "We need a location to post your food.\n\n" +
        `${emoji.INFO} Please share your location or type an address.`
      )
    );
    return;
  }

  // Extract food name from description (first line or first 100 chars)
  const foodName = description.split("\n")[0].substring(0, 100);

  // Create post first (without images)
  const { data: post, error } = await supabase
    .from("posts")
    .insert({
      profile_id: profile.id,
      post_name: foodName,
      post_description: description,
      post_type: "food",
      location: locationPoint, // PostGIS geography point
      post_address: data.locationText || null, // Save the text address if provided
      images: [], // Will update after photo upload
      is_active: true,
      post_views: 0, // Initialize view counter
    })
    .select("id")
    .single();

  if (error) {
    console.error("Error creating post:", error);
    await sendMessage(chatId, t(lang, "common.error", { message: "sharing food" }));
    return;
  }

  // Now upload photo using the post ID as filename
  let imageUrls: string[] = [];
  if (data.photo && post?.id) {
    try {
      const photoUrl = await uploadTelegramPhotoToStorage(data.photo, post.id);
      if (photoUrl) {
        imageUrls = [photoUrl];
        
        // Update post with image URL
        await supabase
          .from("posts")
          .update({ images: imageUrls })
          .eq("id", post.id);
      }
    } catch (error) {
      console.error("Error uploading photo:", error);
      // Continue without photo rather than failing
    }
  }

  const locationNote = !data.location && !profile.latitude ? t(lang, "share.noLocationNote") : "";

  await sendMessage(
    chatId,
    t(lang, "share.success", {
      url: `${APP_URL}/product/${post.id}`,
      locationNote,
    }),
    { reply_markup: { remove_keyboard: true } }
  );
}

// ============================================================================
// Message Handler
// ============================================================================

async function handleMessage(message: TelegramMessage): Promise<void> {
  const chatId = message.chat.id;
  const text = message.text?.trim();
  const userId = message.from?.id;

  if (!userId) return;

  // Handle location messages
  if (message.location) {
    await handleLocationMessage(message);
    return;
  }

  // Handle photo messages
  if (message.photo) {
    await handlePhotoMessage(message);
    return;
  }

  if (!text) return;

  // Handle commands
  if (text.startsWith("/")) {
    const parts = text.split(" ");
    const command = parts[0].toLowerCase();
    const args = parts.slice(1).join(" ");

    switch (command) {
      case "/start":
        await handleStartCommand(chatId, userId, message.from, message.from?.language_code);
        break;
      case "/share":
        if (message.from) {
          await handleShareCommand(chatId, userId, message.from, message.from?.language_code);
        }
        break;
      case "/find":
        await handleFindCommand(chatId, args, message.from?.language_code);
        break;
      case "/nearby":
        await handleNearbyCommand(chatId, userId);
        break;
      case "/profile":
        await handleProfileCommand(chatId, userId);
        break;
      case "/impact":
        await handleImpactCommand(chatId, userId);
        break;
      case "/stats":
        await handleStatsCommand(chatId, userId, message.from?.language_code);
        break;
      case "/leaderboard":
        await handleLeaderboardCommand(chatId, message.from?.language_code);
        break;
      case "/help":
        await handleHelpCommand(chatId);
        break;
      case "/language":
      case "/lang":
        await handleLanguageCommand(chatId, userId);
        break;
      case "/resend":
        if (message.from) {
          await handleResendCode(message.from, chatId);
        }
        break;
      case "/cancel":
        await setUserState(userId, null);
        await sendMessage(chatId, "‚ùå Action cancelled.", {
          reply_markup: { remove_keyboard: true },
        });
        break;
      default:
        // Unknown command - ignore
        break;
    }
  } else {
    // Handle text messages based on user state
    await handleTextMessage(message);
  }

  // Track all messages (including commands)
  try {
    await trackMessage(message);
  } catch (error) {
    console.error("Message tracking error:", error);
  }
}

// ============================================================================
// Webhook Handler
// ============================================================================

Deno.serve(async (req) => {
  const url = new URL(req.url);
  const pathname = url.pathname;

  // Health check endpoint
  if (pathname.endsWith("/health")) {
    return new Response(
      JSON.stringify({
        status: "healthy",
        mode: "webhook",
        version: "2.0.0-raw-api",
      }),
      {
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // Diagnostic endpoint
  if (pathname.endsWith("/diagnostic") && req.method === "GET") {
    return new Response(
      JSON.stringify({
        bot_token_set: !!BOT_TOKEN,
        bot_token_length: BOT_TOKEN?.length || 0,
        app_url: APP_URL,
        supabase_url_set: !!Deno.env.get("SUPABASE_URL"),
        supabase_key_set: !!Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"),
        telegram_api: TELEGRAM_API.replace(BOT_TOKEN || "", "***"),
      }),
      {
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // Webhook info endpoint
  if (pathname.endsWith("/webhook-info") && req.method === "GET") {
    try {
      if (!BOT_TOKEN) {
        return new Response(
          JSON.stringify({
            error: "BOT_TOKEN not configured",
            message: "Set BOT_TOKEN environment variable in Supabase secrets",
          }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }

      const response = await fetch(`${TELEGRAM_API}/getWebhookInfo`);
      const data = await response.json();

      return new Response(JSON.stringify(data), {
        headers: { "Content-Type": "application/json" },
      });
    } catch (error) {
      return new Response(
        JSON.stringify({
          error: error instanceof Error ? error.message : "Unknown error",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
  }

  // Setup webhook endpoint (GET)
  if (pathname.endsWith("/setup-webhook") && req.method === "GET") {
    try {
      if (!BOT_TOKEN) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "BOT_TOKEN not configured",
            message: "Set BOT_TOKEN environment variable in Supabase secrets",
          }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }

      const webhookUrl =
        Deno.env.get("WEBHOOK_URL") ||
        `https://***REMOVED***.supabase.co/functions/v1/telegram-bot-foodshare`;

      const success = await setWebhook(webhookUrl);

      return new Response(
        JSON.stringify({
          success,
          webhook: webhookUrl,
          message: success ? "Webhook configured successfully" : "Webhook setup failed",
        }),
        {
          status: success ? 200 : 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    } catch (error) {
      console.error("Webhook setup error:", error);

      return new Response(
        JSON.stringify({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
  }

  // Webhook endpoint (POST)
  if (req.method === "POST") {
    try {
      const update: TelegramUpdate = await req.json();

      // Handle callback queries (inline button clicks)
      if (update.callback_query) {
        await handleCallbackQuery(update.callback_query);
      }

      // Handle messages
      if (update.message) {
        await handleMessage(update.message);
      }

      // Always return 200 OK to Telegram
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    } catch (error) {
      console.error("Webhook error:", error);

      // Still return 200 to prevent Telegram from retrying
      return new Response(JSON.stringify({ ok: true }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    }
  }

  // Default response
  return new Response(
    JSON.stringify({
      message: "Telegram Bot FoodShare - Raw API Version",
      version: "2.0.0",
      mode: "webhook",
      endpoints: {
        webhook: "POST /",
        health: "GET /health",
        setup: "GET /setup-webhook",
      },
    }),
    {
      headers: { "Content-Type": "application/json" },
    }
  );
});
